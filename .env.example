import React, { useEffect, useState } from 'react';
import { Shield, AlertTriangle } from 'lucide-react';
import { normalizePayload, validatePayload } from '../utils/validation';
import { supabase } from '../utils/supabase';

interface WebhookResponse {
  success: boolean;
  message: string;
  timestamp?: string;
  error?: string;
}

export default function WebhookHandler() {
  const [response, setResponse] = useState<WebhookResponse | null>(null);
  const [isProcessing, setIsProcessing] = useState(false);

  useEffect(() => {
    const handleWebhook = async (payload: any, secret?: string) => {
      try {
        setIsProcessing(true);
        console.log('Webhook received at:', new Date().toISOString());
        console.log('Payload size:', JSON.stringify(payload).length, 'bytes');

        // Validate webhook secret
        const expectedSecret = import.meta.env.VITE_WEBHOOK_SECRET;
        if (expectedSecret && expectedSecret !== 'your_secure_webhook_secret_here') {
          if (!secret) {
            console.error('Webhook secret missing');
            setResponse({
              success: false,
              message: 'Webhook secret required',
              error: 'MISSING_SECRET'
            });
            return;
          }

          if (secret !== expectedSecret) {
            console.error('Invalid webhook secret');
            setResponse({
              success: false,
              message: 'Invalid webhook secret',
              error: 'INVALID_SECRET'
            });
            return;
          }
        }

        const normalized = normalizePayload(payload);
        const validation = validatePayload(normalized);

        if (!validation.valid) {
          console.error('Validation failed:', validation.errors);
          setResponse({
            success: false,
            message: `Validation failed: ${validation.errors?.join(', ')}`,
            error: 'VALIDATION_ERROR'
          });
          return;
        }

        if (!supabase) {
          console.error('Supabase not configured');
          setResponse({
            success: false,
            message: 'Database not configured',
            error: 'DATABASE_ERROR'
          });
          return;
        }

        const { error: dbError } = await supabase
          .from('daily_briefs')
          .upsert({
            title: normalized.title,
            date: normalized.date,
            meta: normalized.meta,
            impact_summary: normalized.impact_summary,
            primary_focus: normalized.primary_focus,
            sections: normalized.sections,
            rapid_updates: normalized.rapid_updates,
            exam_intelligence: normalized.exam_intelligence,
            knowledge_synthesis: normalized.knowledge_synthesis,
            weekly_analysis: normalized.weekly_analysis
          }, {
            onConflict: 'date'
          });

        if (dbError) {
          console.error('Database save error:', dbError);
          setResponse({
            success: false,
            message: `Database error: ${dbError.message}`,
            error: 'DATABASE_ERROR'
          });
          return;
        }

        console.log('Daily content saved to database successfully');
        setResponse({
          success: true,
          message: 'Daily content saved to database successfully',
          timestamp: new Date().toISOString()
        });

      } catch (error) {
        console.error('Webhook processing error:', error);
        setResponse({
          success: false,
          message: 'Internal server error',
          error: 'INTERNAL_ERROR'
        });
      } finally {
        setIsProcessing(false);
      }
    };

    // Parse URL parameters for testing
    const urlParams = new URLSearchParams(window.location.search);
    const testPayload = urlParams.get('test');
    const testSecret = urlParams.get('secret');
    
    if (testPayload) {
      try {
        const payload = JSON.parse(decodeURIComponent(testPayload));
        handleWebhook(payload, testSecret || undefined);
      } catch (error) {
        setResponse({
          success: false,
          message: 'Invalid test payload',
          error: 'INVALID_PAYLOAD'
        });
      }
    }
  }, []);

  return (
    <div className="min-h-screen bg-gray-50 flex items-center justify-center">
      <div className="max-w-md w-full bg-white rounded-lg shadow-lg p-6">
        <div className="flex items-center gap-3 mb-6">
          <Shield className="h-8 w-8 text-blue-600" />
          <h2 className="text-2xl font-bold text-gray-900">Webhook Handler</h2>
        </div>
        
        {/* Security Status */}
        <div className="mb-6 p-4 rounded-lg bg-blue-50 border border-blue-200">
          <div className="flex items-center gap-2 mb-2">
            <Shield className="h-5 w-5 text-blue-600" />
            <span className="font-medium text-blue-900">Security Status</span>
          </div>
          <p className="text-sm text-blue-700">
            {import.meta.env.VITE_WEBHOOK_SECRET && import.meta.env.VITE_WEBHOOK_SECRET !== 'your_secure_webhook_secret_here' 
              ? 'Webhook secret authentication is enabled' 
              : 'No webhook secret configured - all requests accepted'}
          </p>
        </div>

        {isProcessing && (
          <div className="mb-4 p-4 rounded-lg bg-yellow-50 border border-yellow-200">
            <div className="flex items-center gap-2">
              <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-yellow-600"></div>
              <span className="text-yellow-800 font-medium">Processing webhook...</span>
            </div>
          </div>
        )}
        
        {response ? (
          <div className={`p-4 rounded-lg border ${
            response.success 
              ? 'bg-green-50 text-green-800 border-green-200' 
              : 'bg-red-50 text-red-800 border-red-200'
          }`}>
            <div className="flex items-center gap-2 mb-2">
              {response.success ? (
                <Shield className="h-5 w-5 text-green-600" />
              ) : (
                <AlertTriangle className="h-5 w-5 text-red-600" />
              )}
              <p className="font-medium">{response.success ? 'Success' : 'Error'}</p>
            </div>
            <p className="text-sm mt-1">{response.message}</p>
            {response.error && (
              <p className="text-xs mt-2 font-mono bg-black/10 px-2 py-1 rounded">
                Error Code: {response.error}
              </p>
            )}
            {response.timestamp && (
              <p className="text-xs mt-2">Timestamp: {response.timestamp}</p>
            )}
          </div>
        ) : (
            <p>Webhook endpoint ready</p>
            <p className="text-sm mt-2">POST requests will be processed here</p>
          </div>
        )}
        
        <div className="mt-6 text-center">
          <button
            onClick={() => window.history.back()}
            className="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg font-medium transition-colors"
          >
            Go Back
          </button>
        </div>
      </div>
    </div>
  );
}