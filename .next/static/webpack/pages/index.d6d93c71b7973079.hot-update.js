"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./src/utils/storage.ts":
/*!******************************!*\
  !*** ./src/utils/storage.ts ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   archiveDailyBrief: function() { return /* binding */ archiveDailyBrief; },\n/* harmony export */   getArchivedBriefs: function() { return /* binding */ getArchivedBriefs; },\n/* harmony export */   getBriefByDate: function() { return /* binding */ getBriefByDate; },\n/* harmony export */   getBriefsGroupedByMonth: function() { return /* binding */ getBriefsGroupedByMonth; },\n/* harmony export */   getDailyBrief: function() { return /* binding */ getDailyBrief; },\n/* harmony export */   saveDailyBrief: function() { return /* binding */ saveDailyBrief; },\n/* harmony export */   searchBriefs: function() { return /* binding */ searchBriefs; }\n/* harmony export */ });\n/* harmony import */ var _barrel_optimize_names_format_date_fns__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! __barrel_optimize__?names=format!=!date-fns */ \"__barrel_optimize__?names=format!=!./node_modules/date-fns/esm/index.js\");\n\nconst STORAGE_KEY = \"todays-brief-data\";\nconst ARCHIVE_KEY = \"todays-brief-archive\";\nfunction saveDailyBrief(data) {\n    if (false) {}\n    try {\n        // Archive any existing content before saving new content\n        const existingData = getDailyBrief();\n        if (existingData) {\n            archiveDailyBrief(existingData);\n        }\n        localStorage.setItem(STORAGE_KEY, JSON.stringify(data));\n    } catch (error) {\n        console.error(\"Error saving daily brief:\", error);\n    }\n}\nfunction getDailyBrief() {\n    if (false) {}\n    try {\n        const stored = localStorage.getItem(STORAGE_KEY);\n        return stored ? JSON.parse(stored) : null;\n    } catch (error) {\n        console.error(\"Error getting daily brief:\", error);\n        return null;\n    }\n}\nfunction archiveDailyBrief(data) {\n    if (false) {}\n    try {\n        const archive = getArchivedBriefs();\n        const dateKey = (0,_barrel_optimize_names_format_date_fns__WEBPACK_IMPORTED_MODULE_0__.format)(new Date(data.date), \"yyyy-MM-dd\");\n        archive[dateKey] = data;\n        // Store all content without purging\n        localStorage.setItem(ARCHIVE_KEY, JSON.stringify(archive));\n    } catch (error) {\n        console.error(\"Error archiving daily brief:\", error);\n    }\n}\nfunction getArchivedBriefs() {\n    if (false) {}\n    try {\n        const archived = localStorage.getItem(ARCHIVE_KEY);\n        return archived ? JSON.parse(archived) : {};\n    } catch (error) {\n        console.error(\"Error getting archived briefs:\", error);\n        return {};\n    }\n}\nfunction getBriefByDate(date) {\n    if (false) {}\n    const archive = getArchivedBriefs();\n    return archive[date] || null;\n}\nfunction searchBriefs(query, category) {\n    if (false) {}\n    const archive = getArchivedBriefs();\n    const results = [];\n    Object.values(archive).forEach((brief)=>{\n        const searchText = \"\".concat(brief.title, \" \").concat(brief.primary_focus.title, \" \").concat(brief.primary_focus.summary, \" \").concat(brief.sections.map((s)=>s.title + \" \" + s.summary).join(\" \")).toLowerCase();\n        if (searchText.includes(query.toLowerCase())) {\n            if (!category || brief.sections.some((s)=>s.id === category)) {\n                results.push(brief);\n            }\n        }\n    });\n    return results.sort((a, b)=>new Date(b.date).getTime() - new Date(a.date).getTime());\n}\nfunction getBriefsGroupedByMonth() {\n    if (false) {}\n    const archive = getArchivedBriefs();\n    const monthlyGroups = {};\n    Object.values(archive).forEach((brief)=>{\n        const date = new Date(brief.date);\n        const monthKey = (0,_barrel_optimize_names_format_date_fns__WEBPACK_IMPORTED_MODULE_0__.format)(date, \"yyyy-MM\");\n        const monthName = (0,_barrel_optimize_names_format_date_fns__WEBPACK_IMPORTED_MODULE_0__.format)(date, \"MMMM yyyy\");\n        if (!monthlyGroups[monthKey]) {\n            monthlyGroups[monthKey] = {\n                month: monthName,\n                year: date.getFullYear(),\n                count: 0,\n                briefs: []\n            };\n        }\n        monthlyGroups[monthKey].count++;\n        monthlyGroups[monthKey].briefs.push(brief);\n    });\n    // Sort briefs within each month by date (newest first)\n    Object.values(monthlyGroups).forEach((group)=>{\n        group.briefs.sort((a, b)=>new Date(b.date).getTime() - new Date(a.date).getTime());\n    });\n    // Return months sorted by date (newest first)\n    return Object.values(monthlyGroups).sort((a, b)=>b.year - a.year || b.month.localeCompare(a.month));\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Y2s6Ly9fTl9FLy4vc3JjL3V0aWxzL3N0b3JhZ2UudHM/MzUxYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IERhaWx5QnJpZWYgfSBmcm9tICdAL3R5cGVzJztcbmltcG9ydCB7IGZvcm1hdCB9IGZyb20gJ2RhdGUtZm5zJztcblxuY29uc3QgU1RPUkFHRV9LRVkgPSAndG9kYXlzLWJyaWVmLWRhdGEnO1xuY29uc3QgQVJDSElWRV9LRVkgPSAndG9kYXlzLWJyaWVmLWFyY2hpdmUnO1xuXG5leHBvcnQgZnVuY3Rpb24gc2F2ZURhaWx5QnJpZWYoZGF0YTogRGFpbHlCcmllZik6IHZvaWQge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcbiAgXG4gIHRyeSB7XG4gICAgLy8gQXJjaGl2ZSBhbnkgZXhpc3RpbmcgY29udGVudCBiZWZvcmUgc2F2aW5nIG5ldyBjb250ZW50XG4gICAgY29uc3QgZXhpc3RpbmdEYXRhID0gZ2V0RGFpbHlCcmllZigpO1xuICAgIGlmIChleGlzdGluZ0RhdGEpIHtcbiAgICAgIGFyY2hpdmVEYWlseUJyaWVmKGV4aXN0aW5nRGF0YSk7XG4gICAgfVxuICAgIFxuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFNUT1JBR0VfS0VZLCBKU09OLnN0cmluZ2lmeShkYXRhKSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3Igc2F2aW5nIGRhaWx5IGJyaWVmOicsIGVycm9yKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGFpbHlCcmllZigpOiBEYWlseUJyaWVmIHwgbnVsbCB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuIG51bGw7XG4gIFxuICB0cnkge1xuICAgIGNvbnN0IHN0b3JlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFNUT1JBR0VfS0VZKTtcbiAgICByZXR1cm4gc3RvcmVkID8gSlNPTi5wYXJzZShzdG9yZWQpIDogbnVsbDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIGRhaWx5IGJyaWVmOicsIGVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXJjaGl2ZURhaWx5QnJpZWYoZGF0YTogRGFpbHlCcmllZik6IHZvaWQge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcbiAgXG4gIHRyeSB7XG4gICAgY29uc3QgYXJjaGl2ZSA9IGdldEFyY2hpdmVkQnJpZWZzKCk7XG4gICAgY29uc3QgZGF0ZUtleSA9IGZvcm1hdChuZXcgRGF0ZShkYXRhLmRhdGUpLCAneXl5eS1NTS1kZCcpO1xuICAgIFxuICAgIGFyY2hpdmVbZGF0ZUtleV0gPSBkYXRhO1xuICAgIFxuICAgIC8vIFN0b3JlIGFsbCBjb250ZW50IHdpdGhvdXQgcHVyZ2luZ1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKEFSQ0hJVkVfS0VZLCBKU09OLnN0cmluZ2lmeShhcmNoaXZlKSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgYXJjaGl2aW5nIGRhaWx5IGJyaWVmOicsIGVycm9yKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXJjaGl2ZWRCcmllZnMoKTogUmVjb3JkPHN0cmluZywgRGFpbHlCcmllZj4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiB7fTtcbiAgXG4gIHRyeSB7XG4gICAgY29uc3QgYXJjaGl2ZWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShBUkNISVZFX0tFWSk7XG4gICAgcmV0dXJuIGFyY2hpdmVkID8gSlNPTi5wYXJzZShhcmNoaXZlZCkgOiB7fTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIGFyY2hpdmVkIGJyaWVmczonLCBlcnJvcik7XG4gICAgcmV0dXJuIHt9O1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRCcmllZkJ5RGF0ZShkYXRlOiBzdHJpbmcpOiBEYWlseUJyaWVmIHwgbnVsbCB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuIG51bGw7XG4gIFxuICBjb25zdCBhcmNoaXZlID0gZ2V0QXJjaGl2ZWRCcmllZnMoKTtcbiAgcmV0dXJuIGFyY2hpdmVbZGF0ZV0gfHwgbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlYXJjaEJyaWVmcyhxdWVyeTogc3RyaW5nLCBjYXRlZ29yeT86IHN0cmluZyk6IERhaWx5QnJpZWZbXSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuIFtdO1xuICBcbiAgY29uc3QgYXJjaGl2ZSA9IGdldEFyY2hpdmVkQnJpZWZzKCk7XG4gIGNvbnN0IHJlc3VsdHM6IERhaWx5QnJpZWZbXSA9IFtdO1xuICBcbiAgT2JqZWN0LnZhbHVlcyhhcmNoaXZlKS5mb3JFYWNoKGJyaWVmID0+IHtcbiAgICBjb25zdCBzZWFyY2hUZXh0ID0gYCR7YnJpZWYudGl0bGV9ICR7YnJpZWYucHJpbWFyeV9mb2N1cy50aXRsZX0gJHticmllZi5wcmltYXJ5X2ZvY3VzLnN1bW1hcnl9ICR7YnJpZWYuc2VjdGlvbnMubWFwKHMgPT4gcy50aXRsZSArICcgJyArIHMuc3VtbWFyeSkuam9pbignICcpfWAudG9Mb3dlckNhc2UoKTtcbiAgICBcbiAgICBpZiAoc2VhcmNoVGV4dC5pbmNsdWRlcyhxdWVyeS50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgaWYgKCFjYXRlZ29yeSB8fCBicmllZi5zZWN0aW9ucy5zb21lKHMgPT4gcy5pZCA9PT0gY2F0ZWdvcnkpKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaChicmllZik7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgXG4gIHJldHVybiByZXN1bHRzLnNvcnQoKGEsIGIpID0+IG5ldyBEYXRlKGIuZGF0ZSkuZ2V0VGltZSgpIC0gbmV3IERhdGUoYS5kYXRlKS5nZXRUaW1lKCkpO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1vbnRobHlBcmNoaXZlIHtcbiAgbW9udGg6IHN0cmluZztcbiAgeWVhcjogbnVtYmVyO1xuICBjb3VudDogbnVtYmVyO1xuICBicmllZnM6IERhaWx5QnJpZWZbXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEJyaWVmc0dyb3VwZWRCeU1vbnRoKCk6IE1vbnRobHlBcmNoaXZlW10ge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBbXTtcbiAgXG4gIGNvbnN0IGFyY2hpdmUgPSBnZXRBcmNoaXZlZEJyaWVmcygpO1xuICBjb25zdCBtb250aGx5R3JvdXBzOiBSZWNvcmQ8c3RyaW5nLCBNb250aGx5QXJjaGl2ZT4gPSB7fTtcbiAgXG4gIE9iamVjdC52YWx1ZXMoYXJjaGl2ZSkuZm9yRWFjaChicmllZiA9PiB7XG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKGJyaWVmLmRhdGUpO1xuICAgIGNvbnN0IG1vbnRoS2V5ID0gZm9ybWF0KGRhdGUsICd5eXl5LU1NJyk7XG4gICAgY29uc3QgbW9udGhOYW1lID0gZm9ybWF0KGRhdGUsICdNTU1NIHl5eXknKTtcbiAgICBcbiAgICBpZiAoIW1vbnRobHlHcm91cHNbbW9udGhLZXldKSB7XG4gICAgICBtb250aGx5R3JvdXBzW21vbnRoS2V5XSA9IHtcbiAgICAgICAgbW9udGg6IG1vbnRoTmFtZSxcbiAgICAgICAgeWVhcjogZGF0ZS5nZXRGdWxsWWVhcigpLFxuICAgICAgICBjb3VudDogMCxcbiAgICAgICAgYnJpZWZzOiBbXVxuICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgbW9udGhseUdyb3Vwc1ttb250aEtleV0uY291bnQrKztcbiAgICBtb250aGx5R3JvdXBzW21vbnRoS2V5XS5icmllZnMucHVzaChicmllZik7XG4gIH0pO1xuICBcbiAgLy8gU29ydCBicmllZnMgd2l0aGluIGVhY2ggbW9udGggYnkgZGF0ZSAobmV3ZXN0IGZpcnN0KVxuICBPYmplY3QudmFsdWVzKG1vbnRobHlHcm91cHMpLmZvckVhY2goZ3JvdXAgPT4ge1xuICAgIGdyb3VwLmJyaWVmcy5zb3J0KChhLCBiKSA9PiBuZXcgRGF0ZShiLmRhdGUpLmdldFRpbWUoKSAtIG5ldyBEYXRlKGEuZGF0ZSkuZ2V0VGltZSgpKTtcbiAgfSk7XG4gIFxuICAvLyBSZXR1cm4gbW9udGhzIHNvcnRlZCBieSBkYXRlIChuZXdlc3QgZmlyc3QpXG4gIHJldHVybiBPYmplY3QudmFsdWVzKG1vbnRobHlHcm91cHMpLnNvcnQoKGEsIGIpID0+IGIueWVhciAtIGEueWVhciB8fCBiLm1vbnRoLmxvY2FsZUNvbXBhcmUoYS5tb250aCkpO1xufSJdLCJuYW1lcyI6WyJmb3JtYXQiLCJTVE9SQUdFX0tFWSIsIkFSQ0hJVkVfS0VZIiwic2F2ZURhaWx5QnJpZWYiLCJkYXRhIiwiZXhpc3RpbmdEYXRhIiwiZ2V0RGFpbHlCcmllZiIsImFyY2hpdmVEYWlseUJyaWVmIiwibG9jYWxTdG9yYWdlIiwic2V0SXRlbSIsIkpTT04iLCJzdHJpbmdpZnkiLCJlcnJvciIsImNvbnNvbGUiLCJzdG9yZWQiLCJnZXRJdGVtIiwicGFyc2UiLCJhcmNoaXZlIiwiZ2V0QXJjaGl2ZWRCcmllZnMiLCJkYXRlS2V5IiwiRGF0ZSIsImRhdGUiLCJhcmNoaXZlZCIsImdldEJyaWVmQnlEYXRlIiwic2VhcmNoQnJpZWZzIiwicXVlcnkiLCJjYXRlZ29yeSIsInJlc3VsdHMiLCJPYmplY3QiLCJ2YWx1ZXMiLCJmb3JFYWNoIiwiYnJpZWYiLCJzZWFyY2hUZXh0IiwidGl0bGUiLCJwcmltYXJ5X2ZvY3VzIiwic3VtbWFyeSIsInNlY3Rpb25zIiwibWFwIiwicyIsImpvaW4iLCJ0b0xvd2VyQ2FzZSIsImluY2x1ZGVzIiwic29tZSIsImlkIiwicHVzaCIsInNvcnQiLCJhIiwiYiIsImdldFRpbWUiLCJnZXRCcmllZnNHcm91cGVkQnlNb250aCIsIm1vbnRobHlHcm91cHMiLCJtb250aEtleSIsIm1vbnRoTmFtZSIsIm1vbnRoIiwieWVhciIsImdldEZ1bGxZZWFyIiwiY291bnQiLCJicmllZnMiLCJncm91cCIsImxvY2FsZUNvbXBhcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/utils/storage.ts\n"));

/***/ })

});